### 方案

1.   先更新缓存，在更新数据库
2.   先更新数据库，在更新缓存
3.   先删除缓存，后更新数据库
4.   先更新数据库，后删除缓存



### 新增数据类

如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作，此时，缓存中本身就没有新增数据，而数据库中是最新值，此时，缓存和数据库的数据是一致的

### 更新缓存类

#### 1. 先更新缓存，再更新数据库

这个方案一般不考虑。原因是更新缓存成功，更新数据库若出现异常，会导致缓存与数据库数据完全不一致，且难以察觉，因为缓存中的数据一直都存在

#### 2. 先更新数据库，再更新缓存

同上

#### 3. 先删除缓存，后更新数据库

该方案也会出问题，具体出现原因如下。

1.   此时来了2个请求，请求A（更新操作）和请求B（查询操作）
2.   请求A会先删除Redis中的数据，然后去数据库进行更新操作
3.   此时请求B看到Redis中的数据空时，会去数据库中查询该值，补录到Redis中
4.   但是此时请求A并没有更新成功或者事务还未提交，请求B去数据库查询得到旧值
5.   那么这时候就会产生数据库和Redis数据不一致的问题

解决方案？最简单的办法就是延时双删的策略，步骤：

1.   先淘汰缓存
2.   再写数据库
3.   休眠1秒，再次淘汰缓存

伪代码

```python
redis.del(xxx)
db.update(x)
time.sleep(N)
redis.del(xxx)
```

这么做可以将1秒内所造成的缓存脏数据再次删除

具体的休眠时间可以根据业务逻辑确定

##### 拓展

1.   对于存在主从同步的数据库，更新Redis缓存时可以强制从主库获取数据，避免主从同步过程中的延时导致从新获取缓存数据时得到旧数据
2.   同步淘汰策略，导致吞吐量降低怎么办？将第二次的删除作为异步删除
3.   如果第二次删除缓存时失败怎么办？采用下面第四种方案

#### 4. 先更新数据库，后删除缓存

### 如何选择

一般在线上，更多的偏向于使用删除缓存类操作，因为这种方式会更容易避免一些问题

因为删除缓存更新缓存的速度比在DB中要快一些，所以一般情况下我们可能会用先更新DB，后删除缓存的操作。因为这种情况下缓存不一致的情况下只有可能是查询比删除慢的情况，而这种情况相对来说会少很多。同时结合延时双删的处理，可以有效的避免缓存不一致的情况。

