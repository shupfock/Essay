### 过期策略和惰性删除

#### 过期

Redis所有的数据都可以设置过期时间，时间一到，就会自动删除。 但是会不会因为同一时间太多Key过期，以至于忙不过来。同时因为Redis是单线程的，删除的时间也会占用线程的处理时间，如果删除太过频繁，会不会导致线上读写指令出现卡顿

##### 过期的 Key 集合

Redis 会将每个设置了过期时间的Key放入到一个独立的字典中，以后会定时便利这个字典来删除到期的Key。除了定时遍历之外，他还会使用惰性策略来删除过期的Key，所谓惰性策略就是在客户访问这个key的时候，redis对key的过期时间进行检查，如果过期了就会立即删除。定时删除是集中处理，惰性删除是零散处理

#### 定时扫描策略

redis默认会每秒进行10次过期扫描，过期扫描不会遍历过期字典中所有的key，而是采用一种简单的贪心策略。

1.   从过期字典中随机20个key
2.   删除这20个key中已经过期的key
3.   如果过期的key比率超过1/4，就重复步骤1

设想一个大型的redis实例中所有的key在同一时间过期了，会出现怎么样的结果？

毫无疑问，redis会持续扫描过期字典（循环多次），直到过期字典中的过期key变得稀疏，才会停止（循环次数明显下降）。这就会导致线上读写请求出现明显的卡顿现象。导致这种卡顿的另外一个原因是内存管理器需要频繁的回收内存页，这也会产生一定的CPU消耗

所以开发时要注意过期时间，如果有大批量的 key 过期，要给过期时间设置一个随机范围，而不能全部在同一时间过期

#### 从库的过期策略

从库不会进行过期扫描，从库对过期的处理是被动的。主库在key到期时，会在AOF文件里增加一条del指令，同步到所有的从库，从库通过执行这条del指令来删除过期的key

因为指令同步是异步进行的，所以主库过期的key的del指令如果没有及时同步到从库的话，会出现主从不一致

####  惰性删除

所谓惰性策略就是客户端方位这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给客户端返回任何东西

定期删除可能会导致很多key到了时间并没有被删除掉，所以就有了惰性删除



**总结：定期删除是集中处理，惰性删除是零散处理**



### 缓存淘汰算法

当redis内存超过物理内存限制时，内存的数据会开始和磁盘产生频繁的交换（swap)。交互会让Redis的性能急剧下降

#### maxmemory

在生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 maxmemory 来限制内存超出期望大小

当时间内存超出 maxmemory 时，Redis 提供了集中可选策略（maxmemory-policy）来让用户自己决定该如何腾出新的空间以继续提供读写服务

#### Noeviction(默认)

noeviction 不会继续服务写请求(DEL 请求可以继续服务), 读请求可以继续进行. 这样可以保证不会丢失数据, 但是会让线上的业务不能持续进行. 这是默认的淘汰策略

#### volatile-lru

volatile-lru 尝试淘汰设置了过期时间的 key, 最少使用的 key 优先被淘汰. 没有设置过期时间的 key 不会被淘汰, 这种可以保证需要持久化的数据不会突然丢失

#### volatile-ttl

volatile-ttl 跟上面一样, 处理淘汰策略不是 LRU, 而是key 的剩余寿命 ttl 的值, ttl 越小越优先被淘汰

#### volatile-random

volatile-random跟上面一样, 不过淘汰的 key 是国企 key 集合中随机的 key

#### allkeys-lru

allkeys-lru 区别于 volatile-lru, 淘汰的 key 对象是全体 key 集合,而不是只过期的 key 的集合.

#### allkeys-random

allkeys-random 跟上面一样, 不过淘汰的策略是随机的 key 



volatile-xxx 策略只会针对带过期时间的 key 进行淘汰, allkeys-xxx 策略会对所有的 key 进行淘汰. 如果只拿 Redis 做缓存, 那应该使用 allkeys-xxx, 客户端写缓存时不必携带过期时间. 如果同时使用 redis 的持久化功能, 那就使用 volatile-xxx 策略, 这样可以保留没有设置过期时间的 key, 他们是永久的 key 不会被LRU 算法淘汰



#### 近似 LRU 算法

redis 使用的一种近似 LRU 算法. 之所以不使用 LRU 算法, 是因为需要消耗大量的额外内存, 需要对现有的数据结构进行较大的改造

redis 为实现近似 LRU 算法, 它给每一个 key 增加了一个额外的小字段,这个字段长度是 24 个 bit, 也就是最后一次访问的时间戳

当执行 LRU 淘汰算法时, redis 随机采样出 5(可通过 maxmemory-samples配置)个 key, 然后淘汰掉最旧的 key, 如果淘汰后内存还是超过 maxmemory, 那就继续随机采样淘汰, 直到内存低于 maxmemory 为止



