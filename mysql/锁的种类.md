#### Mysql 数据库由于自身构架的特点, 存在多种数据库存储引擎, Mysql 中不同的存储引擎支持不同的锁机制

-   MyISAM 和 MEMORY 存储引擎采用表级锁
-   InnoDB 存储引擎既支持行级锁, 也支持表级锁, 默认情况下采用行级锁
-   BDB 采用的是页面锁, 也支持表级锁



#### 按照数据操作类型分

-   读锁(共享锁): 针对同一份数据, 多个读操作可以同时进行而不会互相影响
-   写锁(排他锁): 当前操作没有完成前, 它会阻断其它写锁和读锁



#### 按照数据操作的力度分

-   表级锁: 开销小, 加锁快; 不会出现死锁; 锁定粒度大, 发生锁冲突的概率最高, 并发度最低
-   行级锁: 开销大, 加锁慢, 会出现死锁; 锁定粒度最小, 发生锁冲突概率最低, 并发度也高
-   页面锁: 开销和加锁时间介于表锁和行锁之间; 会出现死锁; 锁定粒度介于表锁和行锁之间, 并发度一般



#### 按照操作性能可分为乐观锁和悲观锁

-   乐观锁: 一般的实现方式是对记录的数据版本进行比较, 在数据更新提交的时候才会进行冲突检测, 如果发现冲突了,则提示错误信息
-   悲观锁: 在对一条数据修改时, 为了避免同时被其他人修改, 在修改数据前, 先锁定再修改的控制方式. 共享锁和排它锁是悲观锁的不同实现, 但是都属于悲观锁范畴



#### 共享锁和排它锁

##### 行级锁分为共享锁和排他锁

行锁是 mysql 锁中粒度最小的一种锁, 因为锁的粒度很小, 所以发生资源争抢的概率也最小, 并发性能最大, 但是也会造成死锁, 每次加锁和释放锁的开销也会变大

##### 使用 Mysql 行级锁的 2 个前提

-   使用 InnoDB 引擎
-   开始事务(隔离级别为 RR)

##### InnoDB 行锁类型

-   **共享锁(s)**: 当事务对数据加上共享锁后, 其它用户可以并发读取数据, 但任何事物都不能对数据进行修改(获取数据上的排他锁), 直到已释放所有共享锁
-   **排他锁(X)**: 如果事务 T 对数据 A 加上排他锁, 则其他事务不能再对数据 A 加任何类型的封锁. 获准排他锁的事务既能读数据, 又能修改数据

##### 加锁的方式

-   InnoDB 引擎默认更新语句, update, delete, insert 都会自动给涉及的数据加上排他锁, select 语句默认不加任何类型的锁, 如果要加可以使用下面的方式
-   加共享锁(s): select * from table_name where ... lock in share mode;
-   加排他锁(x): select * from table_name where ... for update;

##### 兼容锁

-   共享锁只能兼容共享锁, 不兼容排他锁
-   排他锁互斥共享锁和其他排它锁

