>   可重复读: 一个事物执行过程中看到的数据, 总是跟这个事务在启动时看到的数据是一致的

>   幻读: 当用户读取某一范围的数据行时, 另一个事务又在该范围插入了新行, 当用户在读取该范围的数据时会发现有新的幻影行

**注意: 在可重复读隔离级别下, 普通查询是快照读, 是不会看到别的事务插入的数据的. 因此, 幻读在当前读下才会出现(查询语句添加 for update, 表示当前读)**

表结构

| id   | key  | value |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 1    | 1    | 1     |

假设 `select * from t where value = 1 for update`, 只在这一行加锁(假设), 其它行不加锁, 就会出现如下场景

|      | session A                                                    | session B                            | session C                     |
| ---- | ------------------------------------------------------------ | ------------------------------------ | ----------------------------- |
| T1   | Begin;<br> select * from t where value=1 for update;<br>result: (1,1,1) |                                      |                               |
| T2   |                                                              | update t set value = 1 where id = 0; |                               |
| T3   | begin;<br>select * from t where value =1 for update; <br>result: (0,0,1),(1,1,1) |                                      |                               |
| T4   |                                                              |                                      | Insert into t value (6, 6, 1) |
| T5   | begin;<br>select * from t where value=1 for update; <br>result: (0,0,1),(1,1,1,),(6,6,1) |                                      |                               |
| T6   | commit;                                                      |                                      |                               |

Session A 的三次查询 都是`select * from t where value=1 for update`, 查询 value=1 的所有 row

-   T1: Q1 只返回 1 行(1,1,1);
-   T2: session B 更行 id=0 的 value 为 1, 此时表 t 中 value=1 的数据有 2 行
-   T3: Q2 返回 2 行(0,0,1), (1,1,1)
-   T4: session C 插入一行(6,6,1), 此时表中 value=1 的数据有 3 行
-   T5: Q3 返回(0,0,1), (1,1,1),(6,6,1)
-   T6: session 事务 commit;

其中 Q3 读取到 value=1 这样一行的现象, 就称之为幻读, **幻读指的是一个事物在前后 2 次查询同一个范围的时候, 后一次查询看到了前一次查询没有看到的行**

先对"幻读"做出如下解释:

-   要讨论[可重复读]隔离级别的幻读现象, 是要建立在[当前读]的情况下, 而不是快照读, 因为快照读隔离级别下, 普通的查询是快照读, 是不会看到别的事务插入的数据的



#### Next-key Lock 锁

产生幻读的原因是, 行锁只能锁住行, 但是插入新纪录这个动作, 要更新的是记录之间的"间隙". 因此, InnoDB 引擎为了解决[可重复度]隔离级别使用[当前读]而造成的幻读问题, 就引出了 next-key 锁, 就是记录锁和间隙锁的组合

-   RecordLock锁: 锁定单个行记录的锁(记录锁, RC, RR 隔离级别都支持)
-   GapLock 锁: 间隙锁, 锁定索引记录间隙(不包括记录本身), 确保索引记录间隙不变(范围所, RR 隔离级别支持)
-   Next-key Lock 锁: 记录锁和间隙锁组合, 同时锁住数据, 并且锁住数据前后范围(记录锁+范围所, RR 隔离级别支持)



#### 总结

-   RR 隔离级别下间隙锁才有效, RC 隔离级别下没有间隙锁
-   RR 隔离级别下为了解决"幻读"问题: "快照读"依靠 MVCC, "当前读"通过间隙锁解决
-   间隙锁和行锁合称 Next-key lock, 每个 Next-key lock 是前开后闭区间
-   间隙锁的引入, 可能会导致同样语句锁住更大的范围, 影响并发度